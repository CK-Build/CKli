using CK.Core;
using CK.Setup;
using CK.Text;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace CK.Env.MSBuild
{
    /// <summary>
    /// Encapsulates the result of the dependencies analysis at the solution level.
    /// This is produced by <see cref="DependencyContext.AnalyzeDependencies(Core.IActivityMonitor, SolutionSortStrategy)"/>.
    /// </summary>
    public class SolutionDependencyResult
    {
        /// <summary>
        /// Expanded data that captures for each solution, all referenced projects (<see cref="Target"/>) to
        /// other solutions from its own projects (<see cref="Origin)"/>.
        /// </summary>
        public class DependencyRow
        {
            /// <summary>
            /// Gets the build order for the <see cref="Solution"/>.
            /// </summary>
            public int Index { get; }

            /// <summary>
            /// Gets the solution file.
            /// </summary>
            public Solution Solution { get; }

            /// <summary>
            /// Gets the project that references the package produced by the <see cref="Target"/> project.
            /// Null if <see cref="Solution"/> does not require any other solution.
            /// </summary>
            public Project Origin { get; }

            /// <summary>
            /// Gets the targeted project by <see cref="Origin"/>.
            /// Null if <see cref="Solution"/> does not require any other solution.
            /// </summary>
            public Project Target { get; }

            internal DependencyRow( int idx, Solution s, Project o, Project t )
            {
                Index = idx;
                Solution = s;
                Origin = o;
                Target = t;
            }

            public override string ToString()
            {
                return $"{Index}|{Solution.UniqueSolutionName}|{Origin?.Name}|{Target?.Name}";
            }
        }

        /// <summary>
        /// Simple model for a dependent solution with its direct, minimal and transitive requirements and impacts.
        /// </summary>
        public class DependentSolution
        {
            internal DependentSolution(
                Solution s,
                int index,
                IReadOnlyList<DependencyRow> dependencyTable,
                Func<Solution,DependentSolution> others )
            {
                Solution = s;
                Index = index;
                Requirements = dependencyTable.Where( r => r.Solution == s && r.Target != null )
                                .Select( r => r.Target.Solution )
                                .Distinct()
                                .Select( others )
                                .ToList();
                MinimalRequirements = Requirements.Except( Requirements.SelectMany( r => r.MinimalRequirements ) ).ToList();
                Rank = MinimalRequirements.Count == 0 ? 0 : MinimalRequirements.Max( r => r.Rank ) + 1;
                TransitiveRequirements = Requirements.SelectMany( r => r.TransitiveRequirements ).Distinct().ToList();
            }

            /// <summary>
            /// Gets the rank of this solution.
            /// </summary>
            public int Rank { get; }

            /// <summary>
            /// Gets the index of this solution.
            /// </summary>
            public int Index { get; }

            /// <summary>
            /// Gets the solution.
            /// </summary>
            public Solution Solution { get; }

            /// <summary>
            /// Gets the direct required solutions: this corresponds to the solutions that generate a package
            /// used in this <see cref="Solution"/>.
            /// </summary>
            public IReadOnlyList<DependentSolution> Requirements { get; }

            /// <summary>
            /// Gets the minimal set of required solutions: this is the sub set of the <see cref="Requirements"/>
            /// from which solutions that depend from other required solutions are removed.
            /// </summary>
            public IReadOnlyList<DependentSolution> MinimalRequirements { get; }

            /// <summary>
            /// Gets the maximal set of required solutions (the transitive closure of this <see cref="Requirements"/>).
            /// </summary>
            public IReadOnlyList<DependentSolution> TransitiveRequirements { get; }

            /// <summary>
            /// Gets the direct impacts of this solution: these are all the solutions use at least one package
            /// generated by this <see cref="Solution"/>.
            /// </summary>
            public IReadOnlyList<DependentSolution> Impacts { get; private set; }

            /// <summary>
            /// Gets the minimal set of impacted solutions: this is the sub set of the <see cref="Impacts"/>
            /// from which solutions that impact any other impacted solutions are removed.
            /// </summary>
            public IReadOnlyList<DependentSolution> MinimalImpacts { get; private set; }

            /// <summary>
            /// Gets the maximal set of impacted solutions (the transitive closure of this <see cref="Impacts"/>).
            /// </summary>
            public IReadOnlyCollection<DependentSolution> TransitiveImpacts { get; private set; }

            /// <summary>
            /// Gets the global <see cref="SolutionDependencyResult"/> to which this <see cref="DependentSolution"/> belongs.
            /// </summary>
            public SolutionDependencyResult GlobalResult { get; private set; }

            internal void Initialize( SolutionDependencyResult global )
            {
                GlobalResult = global;
                Impacts = global.DependencyTable.Where( r => r.Target != null && r.Target.PrimarySolution == Solution )
                                                .Select( r => r.Solution )
                                                .Distinct()
                                                .Select( i => global.Solutions.First( d => d.Solution == i ) )
                                                .ToList();
                MinimalImpacts = Impacts.Except( Impacts.SelectMany( r => r.TransitiveImpacts ) ).ToList();
                var transitive = new HashSet<DependentSolution>( Impacts );
                foreach( var i in Impacts.SelectMany( r => r.TransitiveImpacts ) ) transitive.Add( i );
                TransitiveImpacts = transitive;
            }

            /// <summary>
            /// Updates all projects (except BuildProjects) with locally available
            /// better version and saves the solution and its updated projects.
            /// </summary>
            /// <param name="m">The monitor to use.</param>
            /// <param name="feeds">The local feed provider.</param>
            /// <param name="fileSystem">The file system.</param>
            /// <param name="allowDowngrade">Optional allow downgrade. Should not be necessary.</param>
            /// <param name="allowMissing">Defaults to true to be able to start with empty local feeds.</param>
            /// <returns>Whether the upgrade succeeded.</returns>
            public bool UpgradePackagesToTheMax(
                IActivityMonitor m,
                ILocalFeedProvider feeds,
                FileSystem fileSystem,
                bool allowDowngrade = false,
                bool allowMissing = true,
                bool buildProjects = false )
            {
                var all = GlobalResult.ProjectDependencies.DependencyTable
                                    .Where( d => d.SourceProject.Project.PrimarySolution == Solution
                                                 && !d.IsExternalDependency
                                                 && d.SourceProject.Project.IsBuildProject == buildProjects )
                                    .Select( d => (
                                            Row: d,
                                            LocalVersion: feeds.GetBestLocalVersion( m, d.PackageId )) )
                                    .ToList();

                var changes = all.Where( d => d.LocalVersion == null || d.LocalVersion != d.Row.RawPackageDependency.Version );
                var missings = changes.Where( d => d.LocalVersion == null );
                if( missings.Any() )
                {
                    m.Log( allowMissing ? LogLevel.Warn : LogLevel.Fatal,$"Packages not found locally: {missings.Select( u => u.Row.PackageId ).Concatenate()}." );
                    if( !allowMissing ) return false;
                }
                var downgrade = changes.Where( d => d.LocalVersion != null && d.LocalVersion < d.Row.RawPackageDependency.Version );
                if( downgrade.Any() )
                {
                    foreach( var d in downgrade )
                    {
                        m.Log( allowDowngrade ? LogLevel.Warn : LogLevel.Fatal, $"Local package {d.Row.PackageId} found locally in version {d.LocalVersion} but current reference has a greater version {d.Row.RawPackageDependency.Version}." );
                    }
                    if( !allowDowngrade ) return false;
                }
                var availableChanges = changes.Where( c => c.LocalVersion != null );
                using( m.OpenInfo( $"Upgrading {availableChanges.GroupBy( u => u.Row.PackageId ).Count()} locally available packages." ) )
                {
                    foreach( var u in availableChanges )
                    {
                        u.Row.SourceProject.Project.SetPackageReferenceVersion( m, u.Row.SourceProject.Project.TargetFrameworks, u.Row.PackageId, u.LocalVersion );
                    }
                    return Solution.Save( m, fileSystem );
                }
            }

            /// <summary>
            /// Applies an operation on dependencies before applying it to this <see cref="DependentSolution"/>.
            /// </summary>
            /// <param name="m">The monitor to use.</param>
            /// <param name="action">The action to apply.</param>
            /// <returns>True on success, false on error.</returns>
            public bool PullImpacts( IActivityMonitor m, Func<IActivityMonitor, DependentSolution, bool> action )
            {
                return PullImpacts( new HashSet<DependentSolution>(), m, action );
            }

            bool PullImpacts( HashSet<DependentSolution> done, IActivityMonitor m, Func<IActivityMonitor, DependentSolution, bool> action )
            {
                foreach( var d in MinimalRequirements )
                {
                    if( done.Add( d ) ) if( !PullImpacts( done, m, action ) ) return false;
                }
                return action( m, this );
            }

            /// <summary>
            /// Applies an operation to this solution and then to all its <see cref="Impacts"/> recursively.
            /// </summary>
            /// <param name="m">The monitor to use.</param>
            /// <param name="action">The action to apply.</param>
            /// <returns>True on success, false on error.</returns>
            public bool PushImpacts( IActivityMonitor m, Func<IActivityMonitor, DependentSolution, bool> action )
            {
                return PushImpacts( new HashSet<DependentSolution>(), m, action );
            }

            bool PushImpacts( HashSet<DependentSolution> done, IActivityMonitor m, Func<IActivityMonitor, DependentSolution, bool> action )
            {
                if( !action( m, this ) ) return false;
                foreach( var d in MinimalImpacts )
                {
                    if( done.Add( d ) ) if( !PushImpacts( done, m, action ) ) return false;
                }
                return true;
            }
        }

        /// <summary>
        /// Error constructor.
        /// </summary>
        /// <param name="c">The content strategy.</param>
        /// <param name="r">The dependency sorter result.</param>
        internal SolutionDependencyResult( SolutionSortStrategy c, IDependencySorterResult r )
        {
            Debug.Assert( r != null && !r.IsComplete );
            Content = c;
            RawSorterResult = r;
            DependencyTable = Array.Empty<DependencyRow>();
            Solutions = Array.Empty<DependentSolution>();
        }

        internal SolutionDependencyResult(
            SolutionSortStrategy c,
            IDependencySorterResult r,
            ProjectDependencyResult projectDeps,
            IReadOnlyList<DependencyRow> t,
            IReadOnlyList<DependentSolution> solutions )
        {
            Debug.Assert( r != null && r.IsComplete && t != null && solutions != null );
            Content = c;
            RawSorterResult = r;
            ProjectDependencies = projectDeps;
            DependencyTable = t;
            Solutions = solutions;
            for( int i = solutions.Count - 1; i >= 0; --i ) solutions[i].Initialize( this );
        }

        /// <summary>
        /// Gets the kind of projects that have been considered to sort solutions.
        /// </summary>
        public SolutionSortStrategy Content { get; }


        /// <summary>
        /// Gets the project dependency result.
        /// </summary>
        public ProjectDependencyResult ProjectDependencies { get; }


        /// <summary>
        /// Gets the details of the dependencies between solutions.
        /// </summary>
        public IReadOnlyList<DependencyRow> DependencyTable { get; }

        /// <summary>
        /// Gets the global, sorted, dependencies informations between solutions.
        /// </summary>
        public IReadOnlyList<DependentSolution> Solutions { get; }

        /// <summary>
        /// Gets the <see cref="IDependencySorterResult"/> of the Solution/Project graph.
        /// </summary>
        public IDependencySorterResult RawSorterResult { get; }

        /// <summary>
        /// Gets whether solutions and their projects have been successfully ordered.
        /// </summary>
        public bool HasError => !RawSorterResult.IsComplete;



    }

}
