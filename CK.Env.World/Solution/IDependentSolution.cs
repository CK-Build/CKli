using CK.Core;
using System;
using System.Collections.Generic;
using System.Text;

namespace CK.Env
{
    public interface IDependentSolution
    {
        /// <summary>
        /// Gets the solution name. This should be unique across any possible world.
        /// </summary>
        string UniqueSolutionName { get; }

        /// <summary>
        /// Gets the branch name.
        /// Null if <see cref="GitRepository"/> is null or if the solution is not in "branches" or "remotes".
        /// </summary>
        string BranchName { get; }

        /// <summary>
        /// Gets the rank of this solution.
        /// </summary>
        int Rank { get; }

        /// <summary>
        /// Gets the index of this solution in the ordered list <see cref="IDependentSolutionContext.Solutions"/>.
        /// </summary>
        int Index { get; }

        /// <summary>
        /// Gets the git repository to which this solution belongs.
        /// </summary>
        IGitRepository GitRepository { get; }

        /// <summary>
        /// Gets the locally produced packages that are consumed by this solution.
        /// Only packages that are produced by <see cref="Requirements"/> are considered.
        /// </summary>
        IReadOnlyCollection<ImportedLocalPackage> ImportedLocalPackages { get; }

        /// <summary>
        /// Gets the packages produced by this solution that are consumed by other solutions.
        /// Only packages that are used by another solution in the current context are in this set.
        /// To get the set of packages produced, use <see cref="GeneratedPackages"/>.
        /// </summary>
        IReadOnlyCollection<ExportedLocalPackage> ExportedLocalPackages { get; }

        /// <summary>
        /// Gets the set of package names and path that this solution produces, regardless of whether they are used
        /// or not by other solution in the context.
        /// See <see cref="ExportedLocalPackages"/> to know the solutions and projects in the context that
        /// use/consume some or all these packages.
        /// </summary>
        IReadOnlyCollection<GeneratedPackage> GeneratedPackages { get; }

        /// <summary>
        /// Gets the direct required solutions: this corresponds to the solutions that generate a package
        /// used in this <see cref="IDependentSolution"/> (every projects are considered except build projects).
        /// </summary>
        IReadOnlyList<IDependentSolution> Requirements { get; }

        /// <summary>
        /// Gets the direct required solutions for the published packages of this solution:
        /// this corresponds to the solutions that generate a package used by a published package in
        /// this <see cref="Solution"/>.
        /// </summary>
        IReadOnlyList<IDependentSolution> PublishedRequirements { get; }

        /// <summary>
        /// Gets the minimal set of required solutions: this is the sub set of the <see cref="Requirements"/>
        /// from which solutions that depend from other required solutions are removed.
        /// </summary>
        IReadOnlyList<IDependentSolution> MinimalRequirements { get; }

        /// <summary>
        /// Gets the maximal set of required solutions (the transitive closure of this <see cref="Requirements"/>).
        /// </summary>
        IReadOnlyList<IDependentSolution> TransitiveRequirements { get; }

        /// <summary>
        /// Gets the direct impacts of this solution: these are all the solutions that use at least one package
        /// generated by this <see cref="IDependentSolution"/>.
        /// </summary>
        IReadOnlyList<IDependentSolution> Impacts { get; }

        /// <summary>
        /// Gets the minimal set of impacted solutions: this is the sub set of the <see cref="Impacts"/>
        /// from which solutions that impact any other impacted solutions are removed.
        /// </summary>
        IReadOnlyList<IDependentSolution> MinimalImpacts { get; }

        /// <summary>
        /// Gets the maximal set of impacted solutions (the transitive closure of this <see cref="Impacts"/>).
        /// </summary>
        IReadOnlyCollection<IDependentSolution> TransitiveImpacts { get; }


    }
}
