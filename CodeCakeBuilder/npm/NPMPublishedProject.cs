using CK.Core;
using CK.Text;
using CodeCake.Abstractions;
using Kuinox.TypedCLI.Dotnet;
using Kuinox.TypedCLI.NPM;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;

namespace CodeCake
{
    public class NPMPublishedProject : NPMProject, ILocalArtifact
    {
        readonly bool _ckliLocalFeedMode;

        NPMPublishedProject( StandardGlobalInfo globalInfo, NPMSolution npmSolution, SimplePackageJsonFile json, NormalizedPath outputPath )
            : base( globalInfo, npmSolution, json, outputPath )
        {
            _ckliLocalFeedMode = json.CKliLocalFeedMode;
            ArtifactInstance = new ArtifactInstance( new Artifact( "NPM", json.Name ), globalInfo.BuildInfo.Version );
            string tgz = json.Name.Replace( "@", "" ).Replace( '/', '-' );
            TGZName = tgz + "-" + globalInfo.BuildInfo.Version.ToNormalizedString() + ".tgz";
        }

        /// <summary>
        /// Create a <see cref="NPMProject"/> that can be a <see cref="NPMPublishedProject"/>.
        /// </summary>
        /// <param name="globalInfo">The global info of the CodeCakeBuilder.</param>
        /// <param name="dirPath">The directory path where is located the npm package.</param>
        /// <param name="outputPath">The directory path where the build output is. It can be the same than <paramref name="dirPath"/>.</param>
        /// <returns></returns>
        public static NPMProject Create( IActivityMonitor m, StandardGlobalInfo globalInfo, NPMSolution solution, NormalizedPath dirPath, NormalizedPath outputPath )
        {
            var json = SimplePackageJsonFile.Create( m, dirPath );
            NPMProject output;
            if( json.IsPrivate )
            {
                output = CreateNPMProject( globalInfo, solution, json, outputPath );
            }
            else
            {
                output = new NPMPublishedProject( globalInfo, solution, json, outputPath );
            }
            return output;
        }

        public override bool IsPublished => true;

        public ArtifactInstance ArtifactInstance { get; }

        public string Name => ArtifactInstance.Artifact.Name;

        public string TGZName { get; }

        private protected async override Task<bool> DoRunScript( IActivityMonitor m, string scriptName, bool runInBuildDirectory )
        {
            using( TemporarySetPackageVersion( ArtifactInstance.Version ) )
            {
                return await base.DoRunScript( m, scriptName, runInBuildDirectory );
            }
        }

        /// <summary>
        /// Generates the .tgz file in the <see cref="StandardGlobalInfo.ReleasesFolder"/>
        /// by calling npm pack.
        /// </summary>
        /// <param name="globalInfo">The global information object.</param>
        /// <param name="cleanupPackageJson">
        /// By default, "scripts" and "devDependencies" are removed from the package.json file.
        /// </param>
        /// <param name="packageJsonPreProcessor">Optional package.json pre processor.</param>
        public async Task<bool> RunPack( IActivityMonitor m, Action<JObject>? packageJsonPreProcessor = null )
        {
            var tgz = OutputPath.AppendPart( TGZName );
            using( TemporarySetPackageVersion( ArtifactInstance.Version, true ) )
            {
                using( TemporaryPrePack( ArtifactInstance.Version, packageJsonPreProcessor, false ) )
                {
                    IEnumerable<string>? res = await Npm.Pack( m, workingDirectory: OutputPath.ToString(), logLevel: Npm.LogLevel.Info );
                    if( res == null ) return false;
                }

                if( _ckliLocalFeedMode )
                {
                    //It meant that we just build a "dirty" package: we need to build the one that will actually get published.
                    File.Move( tgz, tgz.Path + ".local" );
                    using( TemporaryPrePack( ArtifactInstance.Version, packageJsonPreProcessor, true ) )
                    {
                        IEnumerable<string>? res = await Npm.Pack( m, workingDirectory: OutputPath.ToString() );
                        if( res == null ) return false;
                    }
                }
            }
            if( !File.Exists( tgz ) )
            {
                throw new InvalidOperationException( $"Package file '{tgz}' has not been generated by 'npm pack'." );
            }
            var target = GlobalInfo.ReleasesFolder.AppendPart( TGZName );
            File.Move( tgz.Path, target.Path );
            return true;
        }
    }
}
