using CK.Build;
using System.Collections.Generic;

namespace CK.Env.DependencyModel
{
    /// <summary>
    /// Captures the project dependencies in a <see cref="StartingScope"/> set of solutions
    /// for a given <see cref="ArtifactType"/>.
    /// <para>
    /// This is used to "localize" solutions.
    /// </para>
    /// </summary>
    public sealed class ProjectsDependentInfo
    {
        readonly HashSet<ISolution> _closure;
        readonly Dictionary<Artifact, IProject> _artifactGenerators;
        Dictionary<IProject, IReadOnlySet<IProject>>? _projectDependencies;

        internal ProjectsDependentInfo( ArtifactType artifactType,
                                        ISolution[] scope,
                                        HashSet<ISolution> closure,
                                        Dictionary<Artifact, IProject> artifactGenerators )
        {
            ArtifactType = artifactType;
            StartingScope = scope;
            _closure = closure;
            _artifactGenerators = artifactGenerators;
        }

        /// <summary>
        /// Gets the type of the artifacts that has been considered.
        /// </summary>
        public ArtifactType ArtifactType { get; }

        /// <summary>
        /// Gets the set of solutions that have been considered.
        /// </summary>
        public IReadOnlyList<ISolution> StartingScope { get; }

        /// <summary>
        /// Gets the transitive closure of the <see cref="StartingScope"/>.
        /// <para>
        /// This set may not contain any solution in <see cref="StartingScope"/>
        /// </para>
        /// </summary>
        public IReadOnlySet<ISolution> ScopeClosure => _closure;

        /// <summary>
        /// Gets the map from any artifact generated by the solutions in <see cref="ScopeClosure"/>
        /// to their project.
        /// </summary>
        public IReadOnlyDictionary<Artifact, IProject> ArtifactGenerators => _artifactGenerators;

        /// <summary>
        /// Gets the map from any project in <see cref="ScopeClosure"/> to their dependency
        /// projects (also in the ScopeClosure).
        /// </summary>
        public IReadOnlyDictionary<IProject, IReadOnlySet<IProject>> ProjectDependencies
        {
            get
            {
                if( _projectDependencies == null )
                {
                    // Map for ProjectReference: the closure of dependencies for each project.
                    // This is used to compute the set of $Local that must be added to the .sln in addition to the
                    // transformed PackageReferences to ProjectReferences.
                    var p2p = new Dictionary<IProject, IReadOnlySet<IProject>>();
                    foreach( var p in ArtifactGenerators.Values )
                    {
                        if( !p2p.ContainsKey( p ) )
                        {
                            var deps = new HashSet<IProject>();
                            AddDependencies( _closure, _artifactGenerators, p, deps );
                            p2p.Add( p, deps );
                        }
                    }
                    _projectDependencies = p2p;

                    static void AddDependencies( HashSet<ISolution> closure,
                                                 Dictionary<Artifact, IProject> map,
                                                 IProject p,
                                                 HashSet<IProject> deps )
                    {
                        foreach( var pPack in p.PackageReferences )
                        {
                            // Consider only Transitive dependencies.
                            if( pPack.Kind != ArtifactDependencyKind.Transitive ) continue;
                            if( map.TryGetValue( pPack.Target.Artifact, out var dep ) )
                            {
                                if( deps.Add( dep ) )
                                {
                                    AddDependencies( closure, map, dep, deps );
                                }
                            }
                        }
                        foreach( var pProj in p.ProjectReferences )
                        {
                            if( closure.Contains( pProj.Target.Solution! ) && deps.Add( pProj.Target ) )
                            {
                                AddDependencies( closure, map, pProj.Target, deps );
                            }
                        }
                    }
                }
                return _projectDependencies;
            }
        }

    }
}


