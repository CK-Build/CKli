using CK.Setup;
using CK.Text;
using CK.Core;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;

namespace CK.Env.DependencyModel
{
    /// <summary>
    /// Generic solution: contains a list of <see cref="Project"/> of any type.
    /// </summary>
    public class Solution : TaggedObject, IDependentItemContainerRef, ISolution
    {
        readonly List<Artifact> _generatedArtifacts;
        readonly List<Project> _projects;
        SolutionContext _ctx;
        Project _buildProject;

        internal Solution( SolutionContext ctx, NormalizedPath fullPath, string name )
        {
            _ctx = ctx;
            FullPath = fullPath;
            Name = name;
            _generatedArtifacts = new List<Artifact>();
            _projects = new List<Project>();
        }

        /// <summary>
        /// Gets the solution context.
        /// </summary>
        public SolutionContext Solutions => _ctx;

        ISolutionContext ISolution.Solutions => _ctx;

        /// <summary>
        /// Gets the full path of this solution that must be unique across <see cref="Solutions"/>.
        /// </summary>
        public NormalizedPath FullPath { get; }

        /// <summary>
        /// Gets the solution name that must uniquely identify a solution among multiple solutions.
        /// This is not necessarily the last part of its <see cref="FullPath"/>.
        /// </summary>
        public string Name { get; }

        /// <summary>
        /// Gets all the generated artifacts from all <see cref="Projects"/>.
        /// </summary>
        public IEnumerable<GeneratedArtifact> GeneratedArtifacts => _projects.SelectMany( p => p.GeneratedArtifacts );

        internal void CheckNewArtifact( Artifact a )
        {
            if( a.IsDefault ) throw new ArgumentException( "Invalid artifact.", nameof( a ) );
            if( GeneratedArtifacts.Select( g => g.Artifact ).Contains( a ) )
            {
                throw new InvalidOperationException( $"Artifact '{a}' is already generated by '{ToString()}'." );
            }
        }

        /// <summary>
        /// Gets all the projects.
        /// </summary>
        public IReadOnlyList<Project> Projects => _projects;

        IReadOnlyList<IProject> ISolution.Projects => _projects;

        /// <summary>
        /// Gets or sets the build project. Can be null.
        /// When not null, the project must belong to this <see cref="Projects"/> and both <see cref="Project.IsPublished"/>
        /// and <see cref="Project.IsTestProject"/> must be false.
        /// </summary>
        public Project BuildProject
        {
            get => _buildProject;
            set
            {
                if( _buildProject != value )
                {
                    if( value != null )
                    {
                        if( value.Solution != this ) throw new ArgumentException( "Solution mismatch.", nameof(value) );
                        if( value.IsPublished || value.IsTestProject )
                        {
                            throw new InvalidOperationException( $"Project {ToString()} must not be Published nor be a Test project to be the Solution's BuildProject." );
                        }
                    }
                    _buildProject = value;
                    OnBuildProjectChanged();
                }
            }
        }

        IProject ISolution.BuildProject => _buildProject;

        /// <summary>
        /// Adds a new project
        /// </summary>
        /// <param name="primarySolutionRelativeFolderPath">
        /// The path to the project relative to this <see cref="Solution"/>
        /// </param>
        /// <param name="type">The project type.</param>
        /// <param name="simpleProjecName">The project name.</param>
        public Project AddProject(
            NormalizedPath primarySolutionRelativeFolderPath,
            string type,
            string simpleProjecName )
        {
            if( String.IsNullOrWhiteSpace( type ) ) throw new ArgumentNullException( nameof( type ) );
            if( String.IsNullOrWhiteSpace( simpleProjecName ) ) throw new ArgumentNullException( nameof( simpleProjecName ) );
            var fullFolderPath = FullPath.Combine( primarySolutionRelativeFolderPath );
            var newOne = new Project( this, primarySolutionRelativeFolderPath, fullFolderPath, type, simpleProjecName );
            Debug.Assert( newOne.Name == null );
            if( !_ctx.OnProjectAdding( newOne ) )
            {
                throw new InvalidOperationException( $"Project at '{primarySolutionRelativeFolderPath}' of type '{type}' is already registered in '{ToString()}'." );
            }
            Debug.Assert( newOne.Name != null );
            _projects.Add( newOne );
            _ctx.OnProjectAdded( newOne );
            return newOne;
        }

        /// <summary>
        /// Removes the project (that must belong to this solution otherwise an exception is thrown).
        /// </summary>
        /// <param name="project"></param>
        public void RemoveProject( Project project )
        {
            project.CheckSolution();
            if( project.Solution != this ) throw new ArgumentException( "Solution mismatch.", nameof( project ) );
            Debug.Assert( _projects.Contains( project ) );
            _projects.Remove( project );
            _ctx.OnProjectRemoved( project );
            project.Detach();
        }

        string IDependentItemRef.FullName => Name;

        bool IDependentItemRef.Optional => false;

        /// <summary>
        /// Overridden to return the <see cref="Name"/>.
        /// </summary>
        /// <returns>The solution's name.</returns>
        public override string ToString() => Name;


        void OnBuildProjectChanged()
        {
            _ctx.OnBuildProjectChanged( this );
        }

        internal void OnIsTestProjectChanged( Project project )
        {
            _ctx.OnIsTestProjectChanged( project );
        }

        internal void OnIsPublishedChange( Project project )
        {
            _ctx.OnIsPublishedChange( project );
        }

        internal void OnArtifactAdded( Artifact a, Project project )
        {
            _ctx.OnArtifactAdded( a, project );
        }

        internal void OnArtifactRemoved( Artifact a, Project project )
        {
            _ctx.OnArtifactRemoved( a, project );
        }

        internal void OnPackageReferenceRemoved( PackageReference r )
        {
            _ctx.OnPackageReferenceRemoved( r );
        }

        internal void OnPackageReferenceAdded( PackageReference r )
        {
            _ctx.OnPackageReferenceAdded( r );
        }

        internal void OnProjectReferenceAdded( ProjectReference r )
        {
            _ctx.OnProjectReferenceAdded( r );
        }

        internal void OnProjectReferenceRemoved( ProjectReference r )
        {
            _ctx.OnProjectReferenceRemoved( r );
        }
    }
}
