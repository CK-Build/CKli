using CK.Setup;
using CK.Text;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;

namespace CK.Env
{
    /// <summary>
    /// Genric solution: contains a list of <see cref="DependentProject"/> of any type.
    /// </summary>
    public class PrimarySolution : IDependentItemContainerRef
    {
        readonly List<Artifact> _generatedArtifacts;
        readonly List<DependentProject> _projects;
        DependentProject _buildProject;

        public PrimarySolution( NormalizedPath path, string name )
        {
            FullPath = path;
            Name = name;
            _generatedArtifacts = new List<Artifact>();
            _projects = new List<DependentProject>();
        }

        /// <summary>
        /// Gets the full path of this solution.
        /// </summary>
        public NormalizedPath FullPath { get; }

        /// <summary>
        /// Gets the solution name that must uniquely identify a solution among multiple solutions.
        /// This is not necessarily the last part of the <see cref="FullPath"/>.
        /// </summary>
        public string Name { get; }

        /// <summary>
        /// Gets all the generated artifacts from all <see cref="Projects"/>.
        /// </summary>
        public IEnumerable<Artifact> GeneratedArtifacts => _projects.SelectMany( p => p.GeneratedArtifacts );

        internal void CheckNewArtifact( Artifact a )
        {
            if( a.IsDefault ) throw new ArgumentException( "Invalid artifact.", nameof( a ) );
            if( GeneratedArtifacts.Contains( a ) ) throw new InvalidOperationException( $"Artifact '{a}' is already generated by '{ToString()}'." );
        }

        /// <summary>
        /// Gets all the projects.
        /// </summary>
        public IReadOnlyList<DependentProject> Projects => _projects;

        /// <summary>
        /// Gets or sets the build project. Can be null.
        /// When not null, the project must belong to this <see cref="Projects"/> and <see cref="DependentProject.IsPublished"/>
        /// and <see cref="DependentProject.IsTestProject"/> must be false.
        /// </summary>
        public DependentProject BuildProject
        {
            get => _buildProject;
            set
            {
                if( _buildProject != value )
                {
                    if( value != null )
                    {
                        if( value.Solution != this ) throw new ArgumentException( "Solution mismatch.", nameof(value) );
                        if( value.IsPublished || value.IsTestProject )
                        {
                            throw new InvalidOperationException( $"Project {ToString()} must not be Published nor be a Test project to be the Solution's BuildProject." );
                        }
                    }
                    _buildProject = value;
                }
            }
        }

        /// <summary>
        /// Adds a new project
        /// </summary>
        /// <param name="primarySolutionRelativeFolderPath">
        /// The path to the project relative to this <see cref="Solution"/>
        /// </param>
        /// <param name="fullFolderPath">
        /// The full path to the project folder.
        /// Must be the combination of the solutions'full path and
        /// the <paramref name="primarySolutionRelativeFolderPath"/>.
        /// </param>
        /// <param name="type">The project type.</param>
        /// <param name="simpleProjecName">The project name.</param>
        public void AddProject(
            NormalizedPath primarySolutionRelativeFolderPath,
            NormalizedPath fullFolderPath,
            string type,
            string simpleProjecName )
        {
            if( FullPath.Combine( primarySolutionRelativeFolderPath ) != fullFolderPath )
            {
                throw new ArgumentException( $"Paths mismatch.", nameof( fullFolderPath ) );
            }
            if( _projects.Any( p => p.PrimarySolutionRelativeFolderPath == primarySolutionRelativeFolderPath
                                    && p.Type == type ) )
            {
                throw new InvalidOperationException( $"Project at '{primarySolutionRelativeFolderPath}' of type '{type}' is already registered in '{ToString()}'." );
            }
            if( String.IsNullOrWhiteSpace( type ) ) throw new ArgumentNullException( nameof( type ) );
            if( String.IsNullOrWhiteSpace( simpleProjecName ) ) throw new ArgumentNullException( nameof( simpleProjecName ) );


            bool folderNameRequired = false, typedNameRequired = false;
            foreach( var p in _projects )
            {
                p.OnProjectAdding( simpleProjecName, type, ref folderNameRequired, ref typedNameRequired );
            }
            var newOne = new DependentProject( this, primarySolutionRelativeFolderPath, fullFolderPath, type, simpleProjecName, folderNameRequired, typedNameRequired );
            _projects.Add( newOne );
        }


        string IDependentItemRef.FullName => Name;

        bool IDependentItemRef.Optional => false;
    }
}
